//go:build ignore
// +build ignore

package main

import (
	"bytes"
	"os"
	"strings"
	"text/template"
)

// Defines the types that the string function is generated for.
var types = []string{"Second", "Millisecond"}

const timeTemplate = `// {{ .Type }}s is a type that handles JSON encoding/decoding a time.Duration by the number of
// time.{{ .Type }}'s within it rounded down. This structure is auto-generated.
type {{ .Type }}s time.Duration

// MarshalJSON implements the json.Marshaler interface.
func (x {{ .Type }}s) MarshalJSON() ([]byte, error) {
	var val any = time.Duration(x).{{ .Type }}s()
	var i int64
	switch y := val.(type) {
	case int64:
		i = y
	case float64:
		i = int64(math.Round(y))
	}
	return []byte(strconv.FormatInt(i, 10)), nil
}

// UnmarshalJSON implements the json.Unmarshaler interface.
func (x *{{ .Type }}s) UnmarshalJSON(b []byte) error {
	intVal, err := strconv.ParseInt(string(b), 10, 64)
	if err != nil {
		return err
	}
	*x = {{ .Type }}s(time.{{ .Type }} * time.Duration(intVal))
	return nil
}

// String uses the durafmt package to neatly format the timestamp.
func (x {{ .Type }}s) String() string {
	return durafmt.Parse(time.Duration(x)).String()
}

// {{ .Type }}sFromInt is used to turn a int into the {{ .Type }}s type.
func {{ .Type }}sFromInt(i int) {{ .Type }}s {
	return {{ .Type }}s(time.{{ .Type }} * time.Duration(i))
}`

const fileStart = `package types

// Code generated by generate_time_types.go; DO NOT EDIT.

//go:generate go run generate_time_types.go

import (
	"math"
	"strconv"
	"time"

	"github.com/hako/durafmt"
)

`

func generateFile(typeData []string) string {
	fileContents := fileStart
	fileData := []string{}
	for _, t := range typeData {
		tpl, err := template.New("tpl").Parse(timeTemplate)
		if err != nil {
			panic(err)
		}
		buf := &bytes.Buffer{}
		err = tpl.Execute(buf, map[string]string{"Type": t})
		if err != nil {
			panic(err)
		}
		fileData = append(fileData, buf.String())
	}
	fileContents += strings.Join(fileData, "\n\n")
	return fileContents
}

func main() {
	// Generate the file.
	fileContents := generateFile(types)

	// Write the file.
	err := os.WriteFile("time_types_gen.go", []byte(fileContents+"\n"), 0644)
	if err != nil {
		panic(err)
	}
}
